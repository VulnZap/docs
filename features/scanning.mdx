---
title: "Faraday"
description: "Understanding VulnZap's multi-agent security analysis architecture"
icon: "brain-circuit"
---

## Overview

Faraday represents a paradigm shift in application security scanning—from rule-based analysis to intelligent, context-aware security engineering powered by specialized AI agents working in concert.

## The Problem with Traditional Static Analysis

Traditional static analysis tools rely on:
- **Rigid AST parsing** with predefined pattern matching
- **Hardcoded rules** that generate high false positive rates
- **No business logic understanding** or contextual awareness
- **Pattern-only detection** that misses novel vulnerability patterns

While taint-analysis engines excel at tracking data flow through complex code paths, they face inherent limitations in understanding real-world security implications.

## The Faraday Breakthrough: Agent-Based Intelligence

Instead of rigid AST traversal, Faraday deploys a team of specialized AI agents that collaborate like a human security team—each with distinct expertise, tools, and responsibilities.

## Multi-Agent Architecture

### 1. Vulnerability Scanner Agent

**Role:** Deep code analysis across multiple layers

**Capabilities:**
- **Intra-file analysis:** Single-file vulnerability detection
- **Inter-file analysis:** Cross-file data flow and import tracking
- **Architectural analysis:** System-wide security patterns
- **Hybrid approach:** Traditional taint analysis + AI semantic reasoning

**What it understands:**
```javascript
// Traditional scanners miss this - no direct user input
const config = loadConfig(); // reads from env/file
const query = `SELECT * FROM ${config.tableName}`; // SQL injection if config is tainted

// Faraday traces back to config source and flags the vulnerability
```

### 2. Context Validator Agent

**Role:** The game-changer—eliminates false positives through code verification

**Capabilities:**
- Uses file system tools (`grep`, `readFile`, `find`) to cross-reference findings
- Verifies vulnerabilities against actual code evidence
- Understands sanitization, validation, and protection layers
- Eliminates 90%+ of false positives

**Example:**
```
Finding: Possible SQL injection in getUserData()
Context Validator checks:
  ✓ Input validation present in middleware
  ✓ Parameterized query used
  ✓ ORM with built-in escaping
Result: False positive - marking as safe
```

### 3. Scoring Agent

**Role:** Risk assessment and prioritization

**Capabilities:**
- Assigns CVSS scores based on real exploitability
- Calculates attack vectors and complexity
- Considers authentication requirements
- Evaluates business impact context

**Scoring factors:**
- Is the vulnerable function user-reachable?
- What authentication is required?
- What data is at risk?
- How complex is exploitation?

### 4. Remediation Agent

**Role:** Automated vulnerability fixing

**Capabilities:**
- Generates production-ready patches with precise line boundaries
- Understands code style and project conventions
- Creates minimal, surgical fixes
- Provides detailed fix explanations

**Beyond "found" to "fixed":**

```diff
- const query = `SELECT * FROM users WHERE id = ${userId}`;
+ const query = 'SELECT * FROM users WHERE id = ?';
+ db.query(query, [userId], callback);
```

## How Agent Collaboration Works

<Steps>
  <Step title="Orchestrator Receives Scan Request">
    User initiates: `vulnzap scan`
  </Step>
  
  <Step title="Vulnerability Scanner Analyzes Code">
    Performs deep multi-layer analysis using taint tracking + AI reasoning
  </Step>
  
  <Step title="Context Validator Verifies Findings">
    Cross-references each finding with actual code evidence using file system tools
  </Step>
  
  <Step title="Scoring Agent Assesses Risk">
    Calculates CVSS scores and exploitability based on attack vectors
  </Step>
  
  <Step title="Remediation Agent Generates Patches">
    Creates production-ready fixes with precise line boundaries
  </Step>
</Steps>

<Info>
  All agents coordinate through Redis-backed memory, enabling parallel processing and intelligent task delegation.
</Info>

## The AI Advantage

Each agent leverages advanced language models to:
- **Understand code intent** beyond syntax
- **Reason about business logic** and security implications
- **Detect novel patterns** that rule-based scanners miss
- **Provide context-aware recommendations**

### Intelligence Over Rules

```javascript
// Traditional scanner: ❌ Flags as SQL injection (false positive)
// Faraday: ✅ Understands ORM abstraction provides protection

const user = await User.findOne({
  where: { email: req.body.email } // Sequelize ORM with parameterization
});
```

### Multi-File Vulnerability Detection

Faraday traces data flow across file boundaries:

```javascript
// auth.js
export function getToken(req) {
  return req.headers.authorization; // Source
}

// middleware.js  
import { getToken } from './auth.js';
export function validateUser(req) {
  const token = getToken(req); // Flow
  return jwt.verify(token, secret); // Sink - but safe
}

// Faraday understands the complete flow and validates safety
```

## Performance & Results

### Scan Performance

| Metric | Faraday | Traditional Scanners |
|--------|---------|---------------------|
| **Full repo scan** | 5-7 minutes avg | 30-120 minutes |
| **False positive rate** | &lt;5% | 20-40% |
| **Novel pattern detection** | ✅ Yes | ❌ No |
| **Automated remediation** | ✅ Working patches | ⚠️ Suggestions only |
| **Multi-file analysis** | ✅ Complete flow | ⚠️ Limited |

### Real-World Impact

**Traditional Scanner:**
```
Scan complete: 1,247 findings
├─ 892 false positives (71%)
├─ 312 low severity (25%)
└─ 43 actionable (4%)
Developer time: 8 hours triaging
```

**Faraday:**
```
Scan complete: 67 findings
├─ 3 false positives (4%)
├─ 52 with automated patches (78%)
└─ 67 actionable (100%)
Developer time: 45 minutes reviewing + applying fixes
```

## Running Scans

### Repository Scan

```bash
vulnzap scan --help
```

Initiates full Faraday multi-agent analysis:
1. Vulnerability Scanner analyzes all code
2. Context Validator verifies findings
3. Scoring Agent prioritizes risks
4. Remediation Agent generates patches

## Agent-Aware Development

### MCP Protocol Integration

Faraday integrates with AI coding assistants via Model Context Protocol:

**Supported IDEs:**
- Cursor
- Windsurf  
- Cline
- VS Code (with MCP extension)

**Real-Time Protection:**

When an AI agent generates code, Faraday's Vulnerability Scanner analyzes it instantly and provides secure alternatives:

```
User: "Create a file upload endpoint"

AI generates code → Commits locally -> Initiates a commit scan -> Results given to agent -> Provides secure version

✅ Path traversal protection added
✅ File type validation included  
✅ Size limits enforced
✅ Malware scanning hook added
```

## Why Faraday Changes Everything

### Traditional Approach
```
Rules → AST → Pattern Match → Report → Manual Fix
⚠️ High false positives, no context, manual remediation
```

### Faraday Approach  
```
AI Agents → Multi-layer Analysis → Context Validation → Auto-remediation
✅ Low false positives, full context, automated fixes
```

### Key Differentiators

<CardGroup cols={2}>
  <Card title="Understands Code Intent" icon="brain">
    Goes beyond syntax to understand what code actually does
  </Card>
  
  <Card title="Context-Aware Validation" icon="magnifying-glass">
    Verifies findings against real code evidence
  </Card>
  
  <Card title="Multi-File Intelligence" icon="diagram-project">
    Traces vulnerabilities across complex codebases
  </Card>
  
  <Card title="Production-Ready Patches" icon="wrench">
    Generates working fixes, not just suggestions
  </Card>
</CardGroup>

## The Bottom Line

**Faraday doesn't just find bugs—it understands code like a senior security engineer.**

- **5-7 minute** full repository scans
- **&lt;5%** false positive rate  
- **Automated remediation** with working patches
- **Multi-file vulnerability** detection traditional scanners can't match

Traditional scanners tell you vulnerabilities exist. Faraday understands why they're exploitable and fixes them.

## Next Steps

<CardGroup cols={2}>
  <Card
    title="IDE Integration"
    icon="code"
    href="/features/ide-integration"
  >
    Set up real-time scanning in your editor
  </Card>
  
  <Card
    title="CLI Reference"
    icon="terminal"
    href="/integration/cli"
  >
    Complete command-line documentation
  </Card>
  
  <Card
    title="CI/CD Integration"
    icon="code-branch"
    href="/integration/ci-cd"
  >
    Automate security in your pipeline
  </Card>
</CardGroup>

